=================================

Anton Bergman & Emil Kristiansson

=================================

Task 2.

We used the LTL formula:
<>((statusA == ok) && (statusB == ok))

We used the acceptence verification mode to ensure liveness (no starvation). We did not use weak fairness.


Task 3.

We again use acceptance to ensure liveness of our property.

Spin Trail:
-------------------------------------------------------------
#processes: 3
		partnerA = agentB
		partnerB = agentA
		statusA = err
		statusB = err
 28:	proc  2 (Intruder:1) NS.pml:149 (state 34)
 28:	proc  1 (Bob:1) NS.pml:97 (state 8)
 28:	proc  0 (Alice:1) NS.pml:39 (state 6)
 28:	proc  - (task2:1) _spin_nvr.tmp:3 (state 3)
3 processes created
--------------------------------------------------------------

This means that Alice thinks that she is talking to Bob
	, but the intruder intercepts the message and thus Alice's and Bob's statuses will never be OK.

As in this trace where the intruder intecepts the key, the check:
  (data.key == keyA) && (data.content1 == nonceA);
and corresponding in B will not pass for B, and might not pass for A => Locking bot processes.

Task 6.

We verified the three formulas using the safety mode without weak fairness, as the formulae always should apply.
It should always hold that if the right side of the implication somewhere in the code is true, 
	the left side of the implication should also be true.

The trails for the Spin verification of the respective properties can be found in the files "propAB trail.txt", "propA trail.txt", "propB trail.txt"

propAB and propB does not hold.

propAB is violated when A talks to I and B thunks he's talking to A.

propB is violated when B is ok while thinking he's talking to A and A thinks he's talking to I.

propA holds. 

Task 7.
The fix makes the mad-in-the-middle attack impossible since both A and B know who they are supposed to be talking to.
